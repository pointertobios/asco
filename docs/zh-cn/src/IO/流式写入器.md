# 流式写入器（stream_writer）

`stream_writer<T>`：面向顺序输出场景的行缓冲（可手动刷新）写入工具，对满足 `stream_write` 概念的底层对象提供三种接口：追加写入 `write`、强制写出 `flush`、以及“写入并立即全部写出” `write_all`。不提供读取接口，也不维护读指针。

## 常用 API

| 方法                      | 用途                                                                      | 返回                  |
| ------------------------- | ------------------------------------------------------------------------- | --------------------- |
| `write(buffer<> buf)`     | 将数据追加到内部缓存；若本次数据（含历史缓存）出现首个 `\n`，刷新至该行末 | `future_inline<void>` |
| `write_all(buffer<> buf)` | 追加数据后立即写出全部缓存                                                | `future_inline<void>` |
| `flush()`                 | 将当前缓存全部写出（循环处理底层的“部分写” remainder）                    | `future<void>`        |

行为要点：

1. `write` 仅在发现换行符 `\n`（刷新到该换行符含）或调用 `flush` 才真正写到底层。
2. 未以 `\n` 结尾的数据会暂存在内部缓存；析构时会自动 `flush()`。
3. 若底层 `write` 发生“部分写出”（返回剩余 `buffer`），内部会继续循环直到写完，无需调用方处理。
4. `write_all` 等价于 `write` + 立即 `flush`。

## 快速上手

```cpp
stream_writer sw{std::move(sock)};  // sock 满足 stream_write 概念

// 1. 行模式输出：遇到 \n 自动刷新
co_await sw.write(buffer<>(std::string_view{"Hello, "));
co_await sw.write(buffer<>(std::string_view{"World!\n"}));  // 此处触发写出 "Hello, World!\n"

// 2. 未换行的数据暂存
co_await sw.write(buffer<>(std::string_view{"TailPart"}));

// 3. 需要立刻落盘/发送时显式 flush
co_await sw.flush();  // 写出 "TailPart"

// 4. 或者直接一次性写完
co_await sw.write_all(buffer<>(std::string_view{"AnotherLine\n"}));
```

## 典型使用：逐行日志

```cpp
auto log_line = [&](std::string_view s) -> future<void> {
    std::string buf;
    buf.reserve(s.size() + 1);
    buf.append(s);
    buf.push_back('\n');
    co_await sw.write(buffer<>(std::move(buf)));  // 自动刷新
};
```

## 析构语义

析构会自动执行一次 `flush()`：

- 确保剩余未换行尾部也被写出。
- 若希望明确控制写出点（减少析构时长或错误处理），仍建议在关键路径显式 `flush()`。

## 返回与错误

上述接口返回的 `future` / `future_inline` 仅表示异步完成，不携带写入大小；写失败语义（如底层异常、致命错误）将通过异常或特定底层实现方式传播（视底层 `T` 的行为而定）。

## 何时使用

- 需要按行（或阶段性）批量聚合再输出，降低系统调用次数。
- 需要统一管理缓存并在析构自动冲刷。

## 小提示

- 若输出中没有换行且又需要及时发送，请记得显式 `flush()`。
- 极长单行（迟迟不出现 `\n`）会持续占用内存，可适时手动 `flush()` 以限制缓冲增长。
