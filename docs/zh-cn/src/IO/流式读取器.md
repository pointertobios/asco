# 流式读取器（stream_reader）

`stream_reader<T>`：面向只读顺序数据源的读取工具，提供三类操作：定长读取 `read`、读到 EOF 的 `read_all`、按行增量读取 `read_lines`。

## 常用 API

| 方法                                                                                       | 用途                                                              | 返回                     |
| ------------------------------------------------------------------------------------------ | ----------------------------------------------------------------- | ------------------------ |
| `read(size_t n)`                                                                           | 读取最多 n 字节（到达 EOF 时可能不足 n）                          | `future<buffer<>>`       |
| `read_all()`                                                                               | 读到 EOF（一次性拿完剩余内容，慎用于超大流）                      | `future<buffer<>>`       |
| `read_lines(newline nl, std::optional<future_inline<mutex<>::guard>> lock = std::nullopt)` | 按行增量读取（支持 LF / CR / CRLF），可选在生成器存活期持有互斥锁 | `generator<std::string>` |

换行枚举：`newline::LF`, `newline::CR`, `newline::CRLF`。

行为细节：

- LF 模式：以 `\n` 作为分割，不包含换行本身。
- CR 模式：以 `\r` 作为分割，不包含换行本身。
- CRLF 模式：优先匹配 `\r\n` 作为一行的终止符；若遇到裸 `\r`（后面不是 `\n`），该 `\r` 视为普通数据保留。
- 连续分隔符会产生空行（例如 `"A\r\n\r\nB"` 会得到 `["A", "", "B"]`）。
- 生成器结束（到达 EOF）时，如末尾没有换行，剩余的 `pending` 内容会作为最后一行产出一次。

锁参数：

- `read_lines(nl, mtx.lock())` 支持在生成器的生命周期内持有互斥锁，直至生成器被销毁或耗尽。
- 在生成器活跃期间，`mtx.try_lock()` 将失败；待生成器完成/销毁后锁被释放。

中断（abort）恢复语义：

- 在 `read_lines` 内部，若生成器被打断（abort），其析构会把“已 `co_yield` 但调用方尚未接收”的行缓存回 `stream_reader` 内部。
- 再次调用 `read_lines` 时，会从这些缓存内容继续产出，确保“打断后重新读取可以接着获得刚刚已 `co_yield` 但是还没接收的内容”。

## 快速上手

```cpp
stream_reader sr{std::move(sock)};          // 假设对象 sock 满足 stream_read 概念

// 1. 读取固定大小包头
auto head = co_await sr.read(8);
auto len  = parse_len(head);

// 2. 读取主体
auto body = co_await sr.read(len);

// 3. 读取剩余全部（如果协议允许）
auto remain = co_await sr.read_all();

// 4. 按行读取（如读取一段文本）
auto g = sr.read_lines();
while (auto line = co_await g()) {
    handle_line(line);
}
```

## 按行读取示例（CRLF，典型 HTTP 头）

```cpp
std::vector<std::string> headers;
auto g = sr.read_lines(newline::CRLF);
while (auto line = co_await g()) {
    if (line.empty()) break;   // 空行 = 头结束
    headers.push_back(std::move(line));
}
```

## 锁与中断示例

持锁读取：

```cpp
mutex<> mtx;
auto gen = sr.read_lines(newline::lf, mtx.lock());
// 生成器活跃时，try_lock 失败
assert(!mtx.try_lock().has_value());
// 消费完毕
std::vector<std::string> lines;
while (auto s = co_await gen()) lines.push_back(*s);
// 生成器结束后，锁可再次获取
assert(mtx.try_lock().has_value());
```

打断恢复：

```cpp
auto gen = sr.read_lines(newline::lf);
auto first = co_await gen();      // e.g. "L1"
gen.abort();                      // 打断，已 co_yield 未接收的行将回灌缓存

auto gen2 = sr.read_lines(newline::lf);
while (auto s = co_await gen2()) {
    // 将从被打断前尚未接收的内容继续
}
```

## 返回说明

只需处理：当 `read(n)` 返回的 `buffer` 大小小于请求的 n 且后续再次调用仍为空时，可判定到达 EOF。
