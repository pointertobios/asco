# 流式读取器（stream_reader）

`stream_reader<T>`：面向只读顺序数据源的读取工具，提供三类操作：定长读取 `read`、读到 EOF 的 `read_all`、按行增量读取 `read_lines`。不提供写入接口，也不维护写指针。

## 常用 API

| 方法                     | 用途                                         | 返回                     |
| ------------------------ | -------------------------------------------- | ------------------------ |
| `read(size_t n)`         | 读取最多 n 字节（到达 EOF 时可能不足 n）     | `future<buffer<>>`       |
| `read_all()`             | 读到 EOF（一次性拿完剩余内容，慎用于超大流） | `future<buffer<>>`       |
| `read_lines(newline nl)` | 按行增量读取（支持 LF / CR / CRLF）          | `generator<std::string>` |

换行枚举：`newline::LF`, `newline::CR`, `newline::CRLF`。

## 快速上手

```cpp
stream_reader sr{std::move(sock)};          // 假设对象 sock 满足 stream_read 概念

// 1. 读取固定大小包头
auto head = co_await sr.read(8);
auto len  = parse_len(head);

// 2. 读取主体
auto body = co_await sr.read(len);

// 3. 读取剩余全部（如果协议允许）
auto remain = co_await sr.read_all();

// 4. 按行读取（如读取一段文本）
auto g = sr.read_lines();
while (auto line = co_await g()) {
    handle_line(line);
}
```

## 按行读取示例（CRLF，典型 HTTP 头）

```cpp
std::vector<std::string> headers;
auto g = sr.read_lines(newline::CRLF);
while (auto line = co_await g()) {
    if (line.empty()) break;   // 空行 = 头结束
    headers.push_back(std::move(line));
}
```

## 返回说明

只需处理：当 `read(n)` 返回的 `buffer` 大小小于请求的 n 且后续再次调用仍为空时，可判定到达 EOF。
