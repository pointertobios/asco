# 零拷贝缓冲区

## 简介

`asco::io::buffer` 是一个支持零拷贝的数据缓冲区，适用于高性能 IO 场景。
它通过链式结构管理多个缓冲帧（frame），每个缓冲帧可以是原始数组、字符串或字符串视图，
实现数据的高效拼接与转移，避免不必要的内存拷贝。

## 主要特性

- **零拷贝设计**：通过 `std::variant` 管理不同类型的数据块，减少数据拷贝次数。
- **链式缓冲帧**：每个缓冲帧独立管理，支持动态扩展和拼接。
- **多种数据类型支持**：支持 `char`、`std::byte` 及其字符串类型。
- **高效拼接与转移**：支持将其他 buffer 对象高效拼接进当前缓冲区。

## 主要接口

### 构造与赋值

- `buffer()`：创建一个空缓冲区。
- `buffer(CharT value)`：以单个字符初始化缓冲区。
- `buffer(std::basic_string<CharT> &&str)`：以字符串右值初始化缓冲区。
- `buffer(const std::basic_string_view<CharT> &str)`：以字符串视图初始化缓冲区。
- 禁止拷贝构造，支持移动构造。

### 数据写入

- `void push(CharT value)`：向缓冲区追加单个字符。
- `void push(std::basic_string<CharT> &&str)`：追加字符串（右值）。
- `void push(const std::basic_string_view<CharT> &str)`：追加字符串视图。
- `void push(buffer &&buf)`：拼接另一个 buffer。

### 数据读取

- `std::basic_string<CharT> to_string()`：将缓冲区所有内容合并为一个字符串，并清空缓冲区。

### 其他

- `void swap(buffer &rhs)`：与另一个 buffer 交换内容。

## 使用示例

```cpp
asco::io::buffer<> buf;
buf.push('A');
buf.push(std::string("Hello"));
buf.push(std::string_view("World"));

std::string result = buf.to_string(); // result: "AHelloWorld"
```

## 适用场景

- 网络数据收发缓冲
- 文件 IO 缓冲
- 需要高效拼接、转移大块数据的场景

## 注意事项

- 禁止拷贝构造，避免误用导致多重释放。
- 线程不安全，需自行加锁。
