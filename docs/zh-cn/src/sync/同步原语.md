# 同步原语

本章节介绍 ASCO 提供的基础同步原语，包括互斥锁（Mutex）、读写锁（RWLock）、信号量（Semaphore）与通道（Channel）。它们均为多线程/多协程安全的构件，可与 `future<T>`/`co_await` 无缝配合。

## 何时使用

- Mutex：需要在多个协程/线程之间串行化访问临界区或受保护对象时使用，支持 `with (auto guard = co_await ...)` 的 RAII 写法。
- RWLock：读多写独的场景，可允许大量读者并发访问，写者持锁期间阻塞全部读者与其它写者。
- Semaphore：需要对共享资源进行计数式访问控制，或实现简单的事件/通知机制时使用。适合“一端释放（release），另一端等待（acquire）”的场景。
- Channel：需要在任务之间传递数据（消息）时使用。基于无锁 MPMC 队列封装并配合信号量实现“就绪通知”，保证 FIFO 顺序，可多生产者/多消费者。

## 公共特性

- 线程安全：在多线程/多协程环境下可安全调用。
- 与协程兼容：阻塞等待均以 `co_await` 的方式暴露，不会阻塞线程。
- 异常安全：在常见使用路径中不抛出异常（若违反约束，如在通道关闭后继续发送，将触发 panic）。

## 目录

- [Mutex](./mutex.md)：纯互斥锁及携带数据的互斥锁，推荐用法与注意事项。
- [RWLock](./rwlock.md)：协程友好的读写锁，支持封装对象的读写访问。
- [Semaphore](./semaphore.md)：计数信号量、二值信号量与不限量信号量，API 与使用示例。
- [Channel](./channel.md)：`sender<T>`/`receiver<T>`、`send/recv/try_recv/stop` 语义与注意事项。

## 典型组合用法

- 使用 Channel 进行任务间消息传递；在消费者端如果需要批处理或节流，可结合计时器 `interval` 或 `sleep` 实现节奏控制。
- 使用 Semaphore 表达“完成/可用”事件；多个生产者可安全地 `release(n)` 增加配额，多个消费者以协程方式 `co_await acquire()`。

更多协程与运行时的信息，请先阅读《[`future<T>`下的异步编程](../future.md)》。
