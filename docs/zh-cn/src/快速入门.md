# 快速入门

本章节旨在说明如何基于 ASCO 异步框架编写和构建一个异步程序。

## 选择一种启动异步程序的方式

### 异步主函数

通常来说，`future/promise` 异步模型的异步函数具有传染性，需要一个异步的“**主函数**”作为程序的起点，
通过链接目标 `asco-main` （见 [cmake目标](#cmake目标)段落）导入支持异步“**主函数**”的基本环境。

然后，在你的源代码中导入头文件 `<asco/future.h>` 后，在全局命名空间下定义一个返回 `asco::future<int>` 的异步函数 `future<int> async_main()` ，
不能接收任何参数，通过 `co_return` 返回退出状态码。异步程序将会从此函数开始。

有关如何获取命令行参数和环境变量，见 [future\<T\>](./future.md#异步主函数) 章节。

`asco-main` 实际上是在 `main` 函数中调用 `async_main` 并*阻塞等待*协程返回来实现的。

```c++
#include <asco/future.h>

using asco::future;

future<int> async_main() {
    co_return 0;
}
```

### 同步主函数

在实际的工程中，引入异步主函数会有很多困难，比如：

- 在引入异步框架前可能已经定好了程序的架构，难以从主函数开始将程序重构为异步程序；
- 或者可能仅仅需要一部分异步特性，没必要将整个程序都重构为异步程序；
- 甚至主函数可能实际上是其它第三方库提供的，无法改为异步函数。

因此，***asco*** 同样**支持**主函数保持不变，从同步上下文调用异步函数。
当然，这样并不能直接获取异步函数的返回值，需要通过[*阻塞等待*](./future.md#异步主函数)或[*异步任务组合*](./任务组合.md)来间接处理。

链接目标 `asco-base` 即可用这种方式将异步环境引入你的程序。

## Hello World

```c++
#include <asco/future.h>
#include <asco/print.h>

using asco::future, asco::println;

future<int> async_main() {
    co_await println("Hello, World!");
    co_return 0;
}
```

## cmake目标

- `asco`: `ASCO` 运行时环境，静态目标。
- `asco-main`: 选用异步主函数方式启动需要链接的目标，静态目标。
- `asco-base`: 选用同步主函数方式启动需要链接的目标，静态目标。

后二者不能同时链接。

- `asco-shared`: 目标 `asco` 的动态版本。
- `asco-main-shared`: 依赖 `asco-shared` 的 `asco-main` ，静态目标。
- `asco-base-shared`: 依赖 `asco-shared` 的 `asco-base` ，静态目标。

如需使用动态库，请使用 `-shared` 后缀的目标。

未来可能会加入更多构建系统的支持。
